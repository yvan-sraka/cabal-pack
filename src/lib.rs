mod cabal;
mod cargo;
#[macro_use]
mod errors;
mod flake;
mod hsbindgen;

use cargo::{get_crate_type, CrateType};
use clap::{arg, Parser, Subcommand};
use errors::Error;
use std::process::Command;
use std::{fs, path::Path};

/// A tool that helps you to turn in one command a Rust crate into a Haskell Cabal library
#[derive(Parser)]
#[command(version)]
struct Args {
    #[command(subcommand)]
    cabal: Wrapper,
}

#[derive(Subcommand)]
enum Wrapper {
    #[command(subcommand)]
    Cabal(Commands),
    #[command(subcommand)]
    Stack(Commands),
}

#[derive(Subcommand)]
enum Commands {
    /// Initialize the project by generating custom Cabal files
    Init {
        /// Generate a haskell.nix / naersk based flake.nix
        #[arg(long)]
        enable_nix: bool,
        /// Run a clean before generating files
        #[arg(long)]
        overwrite: bool,
    },
    /// Remove files generated by cargo-cabal, except flake.nix
    Clean,
}

// TODO: rather use https://crates.io/crates/cargo_metadata?!
struct CargoMetadata {
    root: cargo::Root,
    version: String,
    name: String,
    module: String,
}

/// Parse Cargo.toml file content ...
fn parse_cargo_toml() -> Result<CargoMetadata, Error> {
    let cargo = fs::read_to_string("Cargo.toml").or(Err(Error::NoCargoToml))?;
    let root: cargo::Root = toml::from_str(&cargo).or(Err(Error::WrongCargoToml))?;
    let package = root.clone().package.ok_or(Error::NotCargoPackage)?;
    let version = package.version.unwrap_or_else(|| "0.1.0.0".to_owned());
    let name = package.name.ok_or(Error::NoCargoNameField)?;
    let module = name
        .split(&['-', '_'])
        .map(|s| format!("{}{}", &s[..1].to_uppercase(), &s[1..]))
        .collect::<Vec<String>>()
        .join("");
    Ok(CargoMetadata {
        root,
        version,
        name,
        module,
    })
}

/// Parse `cargo-cabal` CLI arguments
pub fn parse_cli_args(args: Vec<String>) -> Result<(), Error> {
    let metadata = parse_cargo_toml()?;
    let (command, enable_stack) = match Args::parse_from(args).cabal {
        Wrapper::Cabal(command) => (command, false),
        Wrapper::Stack(command) => (command, true),
    };
    match command {
        Commands::Init { .. } => cmd_init(command, metadata, enable_stack),
        Commands::Clean => cmd_clean(&metadata.name, enable_stack),
    }
}

/// Initialize the project by generating custom Cabal files
fn cmd_init(args: Commands, metadata: CargoMetadata, enable_stack: bool) -> Result<(), Error> {
    let Commands::Init {
        enable_nix,
        overwrite,
    } = args else { unreachable!() };
    let CargoMetadata {
        root,
        version,
        name,
        module,
    } = metadata;

    // `cargo cabal init --overwrite` == `cargo cabal clean && cargo cabal init`
    if overwrite {
        cmd_clean(&name, enable_stack)?;
    }

    // Check that project have a `crate-type` target ...
    let crate_type = get_crate_type(root).ok_or(Error::NoCargoLibTarget)?;

    // Check that `cargo cabal init` have not been already run ...
    let cabal = format!("{name}.cabal");
    (!(Path::new(&cabal).exists()
        || Path::new(".hsbindgen").exists()
        || Path::new("hsbindgen.toml").exists()
        || Path::new("Setup.hs").exists()
        || Path::new("Setup.lhs").exists()))
    .then_some(())
    .ok_or_else(|| Error::CabalFilesExist(name.to_owned()))?;
    // ... and that no existing file would conflict ...
    if crate_type == CrateType::DynLib {
        (!Path::new("build.rs").exists())
            .then_some(())
            .ok_or(Error::BuildFileExist)?;
    }
    if enable_nix {
        (!Path::new("flake.rs").exists())
            .then_some(())
            .ok_or(Error::FlakeFileExist)?;
    }

    // Generate wanted files from templates ... starting by a `.cabal` ...
    fs::write(
        cabal.clone(),
        cabal::generate(&name, &module, &version, enable_nix),
    )
    .or(Err(Error::FailedToWriteFile(cabal)))?;

    // `hsbindgen.toml` is a config file readed by `#[hs_bindgen]` proc macro ...
    fs::write("hsbindgen.toml", hsbindgen::generate(&module))
        .map_err(|_| Error::FailedToWriteFile("hsbindgen.toml".to_owned()))?;

    // If `crate-type = [ "cdylib" ]` then a custom `build.rs` is needed ...
    if crate_type == CrateType::DynLib {
        fs::write("build.rs", include_str!("build.rs"))
            .map_err(|_| Error::FailedToWriteFile("build.rs".to_owned()))?;
    }

    // `--enable-nix` CLI option generate a `flake.nix` rather than a `Setup.lhs`
    if enable_nix {
        fs::write("flake.nix", flake::generate(&name))
            .map_err(|_| Error::FailedToWriteFile("flake.nix".to_owned()))?;
    } else {
        fs::write("Setup.lhs", include_str!("Setup.lhs"))
            .map_err(|_| Error::FailedToWriteFile("Setup.lhs".to_owned()))?;
    }

    // `--stack` CLI optien initialize a stack project
    if enable_stack {
        Command::new("stack").arg("init").output().unwrap();
    }

    println!(
        "\
Cabal files generated!
**********************
You should now be able to compile your library with `cabal build` and should
add `hs-bindgen` to your crate dependencies list and decorate the Rust function
you want to expose with `#[hs_bindgen]` attribute macro."
    );

    Ok(())
}

/// Remove files generated by cargo-cabal, except flake.nix
fn cmd_clean(name: &str, enable_stack: bool) -> Result<(), Error> {
    let _ = fs::remove_file(format!("{name}.cabal"));
    let _ = fs::remove_file(".hsbindgen");
    let _ = fs::remove_file("hsbindgen.toml");
    let _ = fs::remove_file("Setup.hs");
    let _ = fs::remove_file("Setup.lhs");
    if enable_stack {
        let _ = fs::remove_file("stack.yaml");
        let _ = fs::remove_file("stack.yaml.lock");
    }
    Ok(())
}
